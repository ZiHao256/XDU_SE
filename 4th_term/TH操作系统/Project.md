# **OS 的基本原理与简单实现**

[参考博客](https://www.bookstack.cn/read/simple_os_book/zh-preface-io.md)

[TOC]

# 1 操作系统简介

## 1.1 应具备的背景知识和学习环境

> 设计实现操作系统其实就是设计实现一个可以**管理CPU、内存和各种外设**，并**管理和服务应用软件**的系统软件

* 计算机原理课程
* 程序设计课程
* 掌握C语言

## 1.2 外设

* 计算机系统中的硬件设备（外设），一般连接在计算接系统中 **I/O 总线**上，通过 **I/O 控制器**与 **CPU** 进行交互。
* **I/O 控制器**在物理上包含三个层次：
  * **I/O 地址空间（即 I/O 端口）**：是 CPU 可以直接访问的地址
    * CPU 一般支持 **I/O 地址空间访问**，即通过特定的I/O 访问指令访问
    * 也支持**基于内存的 I/O 地址空间**，即通过一般的访存指令访问
    * 这些 **I/O 访问**请求通过 **I/O 总线**传递给 I/O 接口
  * **I/O 接口**：是处于一组 I/O 端口和对应的设备控制器之间的一种硬件电路
    * 将I/O访问请求中的特定值转换成设备所需要的命令和数据
    * 检测设备的状态变化，及时将各种状态信息写回到特定I/O地址空间，供操作系统通过I/O访问指令来访问
    * I/O接口包括键盘接口、图形接口、磁盘接口、总线鼠标、网络接口、括并口、串口、通用串行总线、PCMCIA接口和SCSI接口等
  * **设备控制器**：只有少数复杂的设备才需要
    * 负责**解释**从I/O接口接收到的高级命令，并将其以适当的方式发送到I/O设备
    * 并且对I/O设备发送的消息进行**解释并修改**I/O端口的状态寄存器

* 操作系统对硬件设备的**控制方式**
  * 程序循环检测方式(**Programmed I/O**，简称PIO)
  * 中断驱动方式**(Interrupt-driven I/O**)
  * 直接内存访问方式(DMA, **Direct Memory Access**)

## 1.3 内存

* 用于存放代码和数据地址的硬件，访问速度快，空间大

* 访问内存空间的索引：内存地址

  * 物理地址
    * CPU 通过总线访问物理内存用到的物理内存
  * 逻辑地址
    * 编写应用程序所用到
    * C 语言中的指针

* > 对于一般的32位CPU而言，以寻址的物理内存地址空间为2\^32= 4 G 字节，支持以页（页大小一般为 4 KB ）为单位对内物理内存空间进行重新编排内存地址，**形成虚拟内存地址**，而**编排虚拟内存地址的策略由操作系统完成**。这样操作系统就可以指定不同的物理内存空间给应用程序，而**应用程序“看到”的是操作系统在CPU的支持下虚拟化后的地址空间**。最终，让操作系统可以更灵活地安排应用程序所占用的内存空间，也简化了应用程序对内存空间的管理。

### 1.3.1 x86 的内存管理

* 32 位的处理器：可以寻址的物理内存地址空间为 2^32 = 4 G 字节
* 三个地址空间概念：
  * **物理地址**
    * 处理器提交到总线上用于访问计算机系统中的内存和外设的**最终地址**
    * 一个计算机系统中只有一个物理地址空间
  * **线性地址**
    * 80386处理器通过**段（Segment）机制**控制下的形成的地址空间
    * **段机制**
      * 在操作系统的管理下，**每个运行**的应用程序有**相对独立**的一个或多个内存空间段，每个段有各自的起始地址和长度属性，大小不固定，这样可让多个运行的应用程序之间**相互隔离**，实现**对地址空间的保护**。
      * 在操作系统完成对80386处理器段机制的**初始化和配置**（*主要是需要操作系统通过特定的指令和操作建立全局描述符表，完成虚拟地址与线性地址的映射关系*）后，80386处理器的**段管理功能单元**负责把虚拟地址转换成线性地址
    * **页机制**
      * **页机制**，每个页的大小是固定的（4 KB），可完成**对内存单元的安全保护，隔离**，可有效**支持大量应用程序分散的使用大内存**的情况
      * 在操作系统完成对80386处理器页机制的**初始化和配置**（*主要是需要操作系统通过特定的指令和操作建立页表，完成虚拟地址与线性地址的映射关系*）后，应用程序看到的**逻辑地址先被处理器中的段管理功能单元转换为线性地址**，然后再通过80386**处理器中的页管理功能单元把线性地址转换成物理地址**。
  * **逻辑地址**

> 页机制和段机制有一定程度的功能重复，但Intel公司为了向下兼容，使得两者一直共存

* 分段机制启动，分页机制为启动时：逻辑地址——**段机制处理**——>线性地址==物理地址
* 两个机制都启动时：逻辑地址——**段机制处理**——>线性地址——**页机制处理**——>物理地址

## 1.4 CPU

CPU 硬件至少支持用户特权级和内核特权级**（控制隔离）**和内存空间隔离**（数据隔离）**

* 通用 CPU 一般能够在硬件上支持内存空间的隔离，使得多个程序在各自独立的内存空间中并发执行
* 这种硬件机制即支持用户特权级和内核特权级
  * **应用程序**运行在用户特权级，这样应用**不能执行特权指令**，且不**能破坏操作系统内核的数据和操作系统执行过程**
  * **操作系统内核运行**在内核特权级，可以**访问特权指令**，并**管理和控制应用程序，硬件外设等**

### 1.4.1 RISC-V 的 CPU 运行模式

* 80386 处理器有四种运行模式
  * Machine 模式
  * Hypervisor 模式
  * Supervisor 模式
  * User 模式
* **实模式**
  * 个人计算机早期8086处理器采用的一种简单运行模式
  * 加点启动后处于实模式运行状态
  * 实模式状态下，软件可访问的物理内存地址空间不能超过1 MB，且无法发挥 Intel 80386以上级别32位 CPU 的4 GB 内存管理能力
  * 实模式将整个物理内存看成分段区域，程序代码和数据位于不同区域
  * 操作系统和用户程序未区别对待，每一个指针都指向实际的物理地址
  * 注意：若用户程序的一个指针指向了操作系统区域或者其他用户程序区域，并修改，后果不堪设想

> 对于ucore无必要涉及

* **保护模式**
  * **主要目标**是确保应用程序无法对操作系统进行破坏
  * 实际上，80386就是通过在**实模式**下初始化**控制寄存器**（如GDTR，LDTR，IDTR与TR等管理寄存器）以及**页表**，然后再通过设置**CR0寄存器**使其中的**保护模式** **使能位置位**，从而进入到80386的保护模式
  * 当80386工作在**保护模式**下的时候，其所有的32根地址线都可供寻址，物理寻址空间高达4 GB
  * 在保护模式下，支持**内存分页机制**，提供了**对虚拟内存的良好支持**
  * **保护模式**下80386支持**多任务**，还支持**优先级机制**，**不同的程序可以运行在不同的特权级上**
    * 特权级一共分0～3四个级别，操作系统运行在最高的特权级0上，应用程序则运行在比较低的级别上；
    * 配合良好的检查机制后，既可以在任务间**实现数据的安全共享**也可以很好地**隔离各个任务**。

## 1.5 计算机硬件架构

* 操作系统在计算机硬件上运行，且**第一要务**：**对硬件进行控制和管理**
* 了解支撑操作系统运行的硬件环境，即了解**处理器体系结构和机器指令集**
* 为了对OS和计算机硬件之间的关系建立一个比较全面和概览性的理解，先理解一个抽象的简化计算机系统，在逐步进入到某一具体CPU，即 RISC-V

### 1.5.1 一般计算机硬件架构

运行操作系统的基本计算机硬件架构

> 一台计算机可抽象一台以**图灵机（Turing Machine）**为理想模型，以**冯诺依曼架构（ Von Neumann Architecture）**为实现模型的电子设备，包括CPU、memory和 I/O 设备

* CPU (中央处理器)：执行操作系统的指令，完成相关计算和读写内存
  * 物理内存保存操作系统的指令和需要处理的数据
  * 外部设备用于实现操作系统的输入（键盘，硬盘），输出（显示器、并口、串口），计时（时钟），永久存储（硬盘）

<img src="https://static.sitestack.cn/projects/simple_os_book/3ae3581d21856d518a4ffe5e28fd90a2.png" alt="计算机抽象图" style="zoom: 50%;" />

#### CPU

*  CPU 是计算机系统的核心
* CPU从一加电开始，从某设定好的内存地址开始，取指令，执行指令，并周而复始地运行
* 取指令的过程即从某寄存器（比如，程序计数器）中获取一个内存地址，从这个内存地址中读入指令，执行机器指令，不断重复
* CPU运行期间会有分支和调用指令来修改程序计数器，实现地址跳转，否则程序计数器就自动加１，让CPU从下一个内存地址单元取指令，并继续执行



* 由于CPU执行速度很快（x86 CPU可达到2 GHZ以上的时钟频率，RISC-V CPU可达到1.5 GHZ的时钟频率），如果当前可以运行的程序太少，则会出现CPU无事可做的情况，导致计算机系统效率太低
* 操作系统除了能管理硬件外，还能管理应用程序，让它们能够按一定的顺序和优先级来依次使用CPU，充分发挥CPU的效能
* 如果管理多个程序的运行，需要考虑如何分配CPU资源的问题，如何避免程序执行期间发生“冲突”的问题等，这是操作系统需要完成的重要功能之一

#### Memory

<img src="https://static.sitestack.cn/projects/simple_os_book/fd1956250ae6d36789720a905d7c7447.png" alt="内存层次图" style="zoom:50%;" />

* 计算机中有多种多层次的存放数据和指令代码的硬件存储单元，比如在CPU内的寄存器（register）、高速缓存(cache)、内存（memory）、硬盘、磁带等
  * **寄存器**位于CPU内部，其访问速度最快但成本昂贵
    * 对于传统的CISC（复杂指令集计算机，如Intel 80386处理器）中一般只有几个到十个左右的通用寄存器，而对于RISC（精简指令集计算机，如RISC-V），则可能有几十个以上通用寄存器
  * **高速缓存（cache）** 一般也在CPU内部，cache是内存和寄存器在速度和大小上的折衷，比寄存器慢2~10倍，容量也有限
    * 量级大约几百KB到几十MB不等
  * **内存**位于CPU外，比寄存器慢10倍以上，但容量大
    * 目前一般以几百兆B到几百GB不等
  * **硬盘**容量更大，但一般比寄存器要慢1000倍以上，不过掉电后其存储的数据不会丢失

* 寄存器、cache、内存、硬盘在读写速度和容量上的巨大差异，所以需要操作系统来协调数据的访问，尽量主动协助应用软件（这样可以达到让多个运行的应用程序“感觉”到它可用使用很大的空间，也可有很快的访问速度）
  * 把最近访问的数据放到寄存器或cache中（实际上操作系统不能直接控制cache的读写）
  * 把经常访问的数据放在内存中
  * 把不常用的数据放到硬盘上
* 让在运行中的每个程序都能够得到“足够大”的内存空间，且程序间相互不能破坏对方的内存“领地”，且建立他们之间的“数据共享”通道，这是操作系统需要完成的重要功能之一。

####  I/O

![IO设备图](https://static.sitestack.cn/projects/simple_os_book/600db03d53232335e8dfaf7293ac594f.png)

* CPU处理的数据需要有来源和输出，这里的来源和输出就是各种外设
  * 键盘、鼠标、显示器、声卡、GPU、U盘、硬盘、SSD存储、打印机、网卡、摄像头等
* 操作系统给应用程序提供了简单的访问接口
  * 应用程序如果直接访问外设，会有代码实现复杂，可移植性差，无法有效并发等问题
  * 应用程序不需要了解硬件细节
* 操作系统通过 CPU 对数据进行加工：读外设数据和写外设数据



* 一般而言，IO外设把它的访问接口映射为一块内存区域，操作系统通过来用通常的内存读写指令来管理设备
* 或者CPU提供了特定的IO操作指令，操作系统通过这些特定的指令来完成对IO外设的访问
* 作系统可以通过轮循、中断、DMA等访问方式来高效地管理外设

