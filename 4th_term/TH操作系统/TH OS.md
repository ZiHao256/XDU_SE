TH OS

[toc]

# 1 Introduction

## 1.1 Preparation

* [ucore 用于实验练习](https://www.bookstack.cn/read/simple_os_book/zh-preface-cpu.md)
* 实验：
  0. 准备
  1. 系统启动及中断
  2. 物理内存管理
  3. 虚拟内存管理
  4. 内核线程管理
  5. 用户进程管理
  6. CPU 调度
  7. 同步与互斥
  8. 文件系统
* 预备：
  * 计算机结构原理
  * 数据结构
  * C + 汇编语言

## 1.2 WHAT

* What is OS：
  * 对上（用户和应用层）：控制
  * 对下（硬件，内存等）：资源管理
    * CPU 抽象为进程
    * 磁盘抽象为文件
    * 内存抽象为地址空间
  * 是承上启下：在硬件之上，应用软件之下
* Kernel 组件：
  * CPU：
    * 调度：进程、线程管理
  * 内存：
    * 物理：
    * 虚拟：提供独立的虚拟内存空间
  * DISK：磁盘块
    * 抽象为文件系统，永久保存数据
  * 中断处理与设备驱动（底层硬件）
* OS Kernel 特征：
  * 并发：
    * 计算机系统中同时存在多个运行的程序，需要操作系统管理与调度
    * 并行：一段时间内同时运行
    * 并发：一个时间点同时运行
  * 共享（资源管理器）：
    * 互斥共享
    * “同时访问”
  * 虚拟：
    * 使得进程觉得独享 CPU
  * 异步：
    * 程序的执行不是一贯到底，而是走走停停
    * 运行环境一样的话，结果也会一样

## 1.3 WHY

* OS:
  * C/C++
  * Structure
  * 算法
  * 计算机体系结构
  * 技能
  * OS 的设计和实现
* Why：
  * developing，needed
  * cool, useful and challenging
* 顶级会议：
  * SOSP
  * LISENIX
* Challenging：
  * 实际OS：了解核心
  * OS 管理并发
  * OS 管理原始硬件
  * OS 代码：高效，低耗CPU；
  * OS 出错的话的代表machine ERROR
  * OS 是安全的基础
* 一些硬件不再是 OS 的重点
* OS 的需求：
  * 时间（CPU）与空间（内存）
  * 可预测性，性能
  * 公平和性能
* 硬件方面：
  * 良好的硬件管理
  * 合理的资源分配
* 硬件细节（重视）

## 1.4 HOW

* [动手实验！！！](https://www.bookstack.cn/read/simple_os_book/zh-preface-cpu.md)

## 1.5 操作系统实例

* Unix 家族(两个工程师)：其中一人 C 语言之父
* BSD：伯克利大学
* Linux 家族：一个学生在校期间
  * Redhat
  * Linux 内核广泛应用与服务器，终端
* Windows 家族：
  * dos + IBM 产生 Windows: 面向用户，推广

## 1.6 历史

* 早期：用纸带传输程序和数据，OS 只起到加载作用
  * 串行，单用户
* CPU 的发展：
  * 顺序执行与批处理
  * 并发特征
* 内存的发展：
  * CPU 执行多个程序
  * 多道程序设计（充分利用CPU）
  * 调度
* 更好的利用资源，更好与用户交互
  * 分时系统（将时间分成小片段）
  * 分时调度
  * 打断：时钟定时打断
* PC OS：
  * 单用户
  * 利用率不再重要
  * GUI 和 API
  * I/O 交互性
* 随着网络的发展
  * 分布式操作系统（Internet）
  * 松紧耦合系统
* Future OS
  * 普适计算
  * 嵌入式。。。

## 1.7 操作系统结构

* MS DOS (硬件限制)
* 汇编语言与硬件binding，不具可移植性
* C 语言编写: 可移植性
* 微内核：松耦合
  * 尽可能把内核功能移至用户空间
  * 性能降低，交互提高
* 外核（exokernel）
  * 速度提高
  * 与Application紧密
* VMM：

## 1.8 conclusion

# 2 操作系统

## 2.1 操作系统的启动

* 启动

* 中断，异常，系统调用

* 启动

  * DISK：存放 OS
  * BIOS：（Basic I/O System)
    * 开机后检查外设
  * Bootloader ：加载 OS，从 DISK 中加载到 Memory 中

* 操作系统与设备和程序的交互

  * Interface：与外设交互：中断，I/O；

    ​					与 Application ： 系统调用，异常

* Definition：

  * 系统调用（来源于 Application）
    * Application 主动向 OS 发出 Service Call
  * 异常（来自不良的 Application），以应对意想不到
    * 非法指令或者其他坏的状态
  * 中断（源于外设）
    * 不同的硬件设备的计时器和网络中断

* Why Application 不直接访问硬件

  1. OS 更被硬件所信任
  2. 只有内核可以执行特权指令
  3. 为了方便Application：
     1. 将 Device 的复杂性屏蔽
     2. 提供见解的接口

* 处理时间

  * 中断：异步
  * 异常：同步
  * Sys Call：同步（发出）和异步（返回）

* 响应

  * 中断：持续，对 Application 透明
  * 异常：杀死或者重新执行程序
  * Sys Call：等待和持续

## 2.2 操作系统的中断，异常和系统调用

* 中断处理机制
  * 硬件
    * 设置中断标记[CPU初始化]
    * 将内部、外部事件设置中断标记
    * 产生中断事件 ID
  * 软件（OS）
    * 保存当前处理状态
      * 进程状态
    * 中断服务程序处理
    * 清除中断标记
    * 恢复之前处理状态
* 异常处理机制
  * 产生异常事件标记
  * 保存现场
  * 异常处理
    * 杀死产生异常的程序
    * 重新执行异常的程序
    * 恢复
* 系统调用处理机制
  * System Call Interface
  * 程序访问主要是通过高层次的 API 而非直接进行系统调用
* System Call 与 Function Call
  * System Call：
    * Application 与 OS 拥有各自的堆栈
    * 需要切换堆栈
    * 切换 CPU 特权级转换
    * 有开销，但更安全
  * Function Call
    * Application 在一个堆栈空间中：
      * 参数传递与返回
* 跨越操作系统边界的开销
  * 在执行时间上的开销超过程序调用
  * 开销
    * 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
    * 建立内核堆栈
    * 验证参数
    * 内核态映射到到用户态的地址空间
      * 更新页面映射权限
    * 内核态独立地址空间
      * TLB

# 3 连续内存分配

## 3.1 计算机体系结构及内存分层体系



## 3.2 地址空间与地址生成

* 地址空间
* 

## 3.3 连续内存分配：内存碎片与分区的动态分配

## 3.4 连续内存分配：压缩式与交换式碎片整理

* 压缩式
* 交换式（swapping）
  * 充分利用硬盘
  * 将 process 的数据从 memory 拷贝入 DISK 中

# 4 非连续内存分配

## 4.1 非连续内存分配：分段

* 为什么需要非连续内存分配
  * 分段 Segment
  * 分页 Paging
  * 页表 Page Table
* 分段：更好的分离共享

## 4.2 非连续内存分配：分页

* 与分段的区别
  * 段大小可变
  * 页大小固定

## 4.3 非连续内存分配：页表概述-TLB

## 4.4 非连续内存分配：页表-二级，多级页表

## 4.5 非连续内存分配：页表-反向页表

# 5

## 5.1 虚拟内存的起因